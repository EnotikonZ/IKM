# Используя структуру стека, вычислить выражение, содержащее две операции: поиск минимума
# (обозначается m(<число1>,<число2>)) и поиск максимума (обозначается М(<число1>,<число2>)). Операции могут быть вложенными,
# например, M(15, m(16,8)) (в данном выражении ищем минимум из 16 и 8, а потом ищем максимум от результата
# m(16,8) и 15, ответ 15). В качестве аргументов могут использоваться только целые положительные числа.
# Строка, вводимая пользователем, корректна и не содержит пробелов.
"""
Калькулятор для выражений вида m(…), M(…).

Формат:
    • m(a,b)  — минимум двух положительных целых a и b
    • M(a,b)  — максимум двух положительных целых a и b
    • Операции можно вкладывать друг в друга, например:
        M(15,m(16,8))
    • Разрешены только символы: цифры 0-9, буквы m/M, скобки ( ), запятая ,
    • Пробелов быть не должно.
    • Пустая строка завершает работу калькулятора.
"""

# ──────────────────── Узел и стек ───────────────────────────────────────────
class Node:                                      # узел односвязного списка
    def __init__(self, value, nxt=None):         # значение + ссылка
        self.value = value                       # само значение
        self.next  = nxt                         # ссылка на следующий узел

class Stack:                                     # стек LIFO на односвязном списке
    def __init__(self):
        self.head = None                         # вершина стека
        self.size = 0                            # текущее количество элементов

    def push(self, value):                       # кладём элемент наверх
        self.head = Node(value, self.head)       # новый узел → старая вершина
        self.size += 1                           # увеличиваем размер

    def pop(self):                               # снимаем верхний элемент
        if self.head is None:                    # пустой стек → ошибка
            raise ValueError("Стек пуст")
        value = self.head.value                  # сохраняем значение
        self.head = self.head.next               # сдвигаем вершину
        self.size -= 1                           # уменьшаем размер
        return value                             # возвращаем извлечённое

    def __len__(self):                           # позволяет вызвать len(stack)
        return self.size

# ──────────────────── Валидация выражения ──────────────────────────────────
def validate(expr):
    """Проверяет допустимые символы и баланс скобок."""
    if len(expr) == 0:                           # пустая строка
        raise ValueError("Пустая строка")
    balance = 0                                  # счётчик скобок
    for ch in expr:
        if not (('0' <= ch <= '9') or ch in "mM(),"):
            raise ValueError("Недопустимый символ: " + ch)
        if ch == '(':
            balance += 1                         # открыли скобку
        elif ch == ')':
            balance -= 1                         # закрыли скобку
            if balance < 0:
                raise ValueError("Лишняя закрывающая скобка")
    if balance != 0:
        raise ValueError("Скобки не сбалансированы")

# ──────────────────── Основной вычислитель ─────────────────────────────────
def eval_min_max(expr):
    """Вычисляет корректное выражение из m/M, используя два стека."""
    validate(expr)                               # защита от дурака

    ops  = Stack()                               # стек операций
    vals = Stack()                               # стек чисел
    i = 0                                        # текущая позиция курсора

    while i < len(expr):
        ch = expr[i]

        if '0' <= ch <= '9':                     # начинаем читать число
            num = 0
            while i < len(expr) and '0' <= expr[i] <= '9':
                num = num * 10 + int(expr[i])    # «сдвиг» + цифра
                i += 1
            vals.push(num)                       # кладём число в стек
            continue                             # уже на новом символе

        if ch == 'm' or ch == 'M':               # встретили имя функции
            ops.push(ch)                         # сохраняем тип операции
        elif ch == ')':                          # закрылась пара аргументов
            b = vals.pop()                       # второй аргумент
            a = vals.pop()                       # первый  аргумент
            op = ops.pop()                       # операция m/M
            if op == 'm':                        # min
                vals.push(a if a < b else b)
            else:                                # max
                vals.push(a if a > b else b)
        # символы '(' и ',' пропускаем
        i += 1                                   # шаг вперёд

    if len(vals) != 1 or len(ops) != 0:          # в конце должен остаться 1 результат
        raise ValueError("Некорректное выражение")
    return vals.pop()

# ──────────────────── Дружественный REPL ───────────────────────────────────
def repl():
    """Интерактивный режим: принимает выражения, выводит результат."""
    print(__doc__.strip())                       # выводим инструкцию из docstring
    print()                                      # пустая строка-отступ
    while True:
        expr = input(">>> ").strip()             # читаем ввод пользователя
        if expr == "":                           # пустая строка → выход
            print("До свидания!")
            break
        try:
            result = eval_min_max(expr)          # вычисляем выражение
            print("Результат:", result)          # печатаем ответ
        except ValueError as err:                # ловим ошибки парсинга
            print("Ошибка:", err)

# ──────────────────── Точка входа ──────────────────────────────────────────
if __name__ == "__main__":
    repl()
