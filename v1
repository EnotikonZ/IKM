# Используя структуру стека, вычислить выражение, содержащее две операции: поиск минимума
# (обозначается m(<число1>,<число2>)) и поиск максимума (обозначается М(<число1>,<число2>)). Операции могут быть вложенными,
# например, M(15, m(16,8)) (в данном выражении ищем минимум из 16 и 8, а потом ищем максимум от результата
# m(16,8) и 15, ответ 15). В качестве аргументов могут использоваться только целые положительные числа.
# Строка, вводимая пользователем, корректна и не содержит пробелов.
"""
Калькулятор для выражений вида m(…), M(…).

Формат:
    • m(a,b)  — минимум двух положительных целых a и b
    • M(a,b)  — максимум двух положительных целых a и b
    • Операции можно вкладывать друг в друга, например:
        M(15,m(16,8))
    • Разрешены только символы: цифры 0-9, буквы m/M, скобки ( ), запятая ,
    • Пробелов быть не должно.
    • Пустая строка завершает работу калькулятора.
"""

# ──────────────────── Узел и стек ───────────────────────────────────────────
class Node:                                      # узел односвязного списка
    def __init__(self, value, nxt=None):         # значение + ссылка
        self.value = value                       # само значение
        self.next  = nxt                         # ссылка на следующий узел

class Stack:                                     # стек LIFO на односвязном списке
    def __init__(self):
        self.head = None                         # вершина стека
        self.size = 0                            # текущее количество элементов

    def push(self, value):                       # кладём элемент наверх
        self.head = Node(value, self.head)       # новый узел → старая вершина
        self.size += 1                           # увеличиваем размер

    def pop(self):                               # снимаем верхний элемент
        if self.head is None:                    # пустой стек → ошибка
            raise ValueError("Стек пуст")
        value = self.head.value                  # сохраняем значение
        self.head = self.head.next               # сдвигаем вершину
        self.size -= 1                           # уменьшаем размер
        return value                             # возвращаем извлечённое

    def __len__(self):                           # позволяет вызвать len(stack)
        return self.size

# ──────────────────── Валидация выражения ──────────────────────────────────
def validate(expr):
    """Проверяет допустимые символы и баланс скобок."""
    if len(expr) == 0:                           # пустая строка
        raise ValueError("Пустая строка")
    balance = 0                                  # счётчик скобок
    for ch in expr:
        if not (('0' <= ch <= '9') or ch in "mM(),"):
            raise ValueError("Недопустимый символ: " + ch)
        if ch == '(':
            balance += 1                         # открыли скобку
        elif ch == ')':
            balance -= 1                         # закрыли скобку
            if balance < 0:
                raise ValueError("Лишняя закрывающая скобка")
    if balance != 0:
        raise ValueError("Скобки не сбалансированы")

# ──────────────────── Основной вычислитель ─────────────────────────────────
def eval_min_max(expr):
    """Вычисляет выражение из операций m и M, используя два стека."""

    validate(expr)  # Проверяем корректность строки (символы, баланс скобок)

    ops = Stack()   # Стек для операций: 'm' и 'M'
    vals = Stack()  # Стек для чисел и промежуточных результатов
    i = 0           # Позиция текущего символа в строке

    while i < len(expr):          # Пока не дошли до конца строки
        ch = expr[i]              # Берём текущий символ

        if '0' <= ch <= '9':      # Если это цифра — начинаем читать число
            num = 0
            while i < len(expr) and '0' <= expr[i] <= '9':  # Пока видим цифры
                num = num * 10 + int(expr[i])               # Собираем число
                i += 1                                      # Двигаемся вперёд
            vals.push(num)           # Кладём число в стек значений
            continue                 # Продолжаем цикл (i уже обновлён)

        if ch == 'm' or ch == 'M':   # Встретили имя функции
            ops.push(ch)            # Кладём операцию в стек
            i += 1                  # Важно! Переходим к следующему символу
            continue                # Переход к следующей итерации

        elif ch == ')':  # Закрывающая скобка: пора вычислить
            if len(vals) < 2:  # Нужно минимум два аргумента
                raise ValueError("Недостаточно аргументов для операции")
            if len(ops) < 1:  # Должна быть хотя бы одна операция
                raise ValueError("Нет операции для выполнения")
            b = vals.pop()  # Второй аргумент
            a = vals.pop()  # Первый аргумент
            op = ops.pop()  # Операция (m или M)
            # Вычисляем и кладём результат обратно в стек значений
            vals.push(min(a, b) if op == 'm' else max(a, b))
            i += 1  # <<–– Сдвигаемся на следующий символ!
            continue

        # Символы (, и , просто пропускаем — ничего делать не нужно
        i += 1  # Переход к следующему символу (если это не цифра)

    # После разбора всего выражения проверяем финальное состояние
    if len(vals) != 1:
        raise ValueError("После вычислений должно остаться одно значение")
    if len(ops) != 0:
        raise ValueError("Остались необработанные операции")

    return vals.pop()  # Возвращаем итоговое значение



# ──────────────────── Дружественный REPL ───────────────────────────────────
def repl():
    """Интерактивный режим: принимает выражения, выводит результат."""
    print(__doc__.strip())                       # выводим инструкцию из docstring
    print()                                      # пустая строка-отступ
    while True:
        expr = input(">>> ").strip()             # читаем ввод пользователя
        if expr == "":                           # пустая строка → выход
            print("До свидания!")
            break
        try:
            result = eval_min_max(expr)          # вычисляем выражение
            print("Результат:", result)          # печатаем ответ
        except ValueError as err:                # ловим ошибки парсинга
            print("Ошибка:", err)

# ──────────────────── Точка входа ──────────────────────────────────────────
if __name__ == "__main__":
    repl()
